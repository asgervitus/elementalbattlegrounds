<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Elemental Battlegrounds - Offline</title>
  <style>
    /*
     * Complete styles for the Elemental Battlegrounds game - self-contained
     */
    
    /* Global animation keyframes */
    @keyframes fadeInUp {
      from {
        opacity: 0;
        transform: translateY(30px);
      }
      to {
        opacity: 1;
        transform: translateY(0);
      }
    }

    @keyframes fadeInScale {
      from {
        opacity: 0;
        transform: scale(0.8);
      }
      to {
        opacity: 1;
        transform: scale(1);
      }
    }

    @keyframes slideInRight {
      from {
        opacity: 0;
        transform: translateX(50px);
      }
      to {
        opacity: 1;
        transform: translateX(0);
      }
    }

    @keyframes slideInLeft {
      from {
        opacity: 0;
        transform: translateX(-50px);
      }
      to {
        opacity: 1;
        transform: translateX(0);
      }
    }

    @keyframes pulse {
      0%, 100% { 
        transform: scale(1); 
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
      }
      50% { 
        transform: scale(1.02); 
        box-shadow: 0 4px 8px rgba(0, 0, 0, 0.15);
      }
    }

    @keyframes bounce {
      0%, 20%, 53%, 80%, 100% {
        transform: translateY(0);
      }
      40%, 43% {
        transform: translateY(-8px);
      }
      70% {
        transform: translateY(-4px);
      }
      90% {
        transform: translateY(-2px);
      }
    }

    @keyframes shake {
      0%, 100% { transform: translateX(0); }
      10%, 30%, 50%, 70%, 90% { transform: translateX(-2px); }
      20%, 40%, 60%, 80% { transform: translateX(2px); }
    }

    @keyframes glow {
      0%, 100% { 
        box-shadow: 0 0 5px rgba(0, 123, 255, 0.3);
      }
      50% { 
        box-shadow: 0 0 20px rgba(0, 123, 255, 0.6);
      }
    }

    @keyframes sparkle {
      0%, 100% { 
        opacity: 0;
        transform: scale(0) rotate(0deg);
      }
      50% { 
        opacity: 1;
        transform: scale(1) rotate(180deg);
      }
    }

    @keyframes damage {
      0% { 
        transform: scale(1);
        filter: brightness(1);
      }
      25% { 
        transform: scale(1.1);
        filter: brightness(1.5) hue-rotate(0deg);
      }
      50% { 
        transform: scale(0.9);
        filter: brightness(1.2) hue-rotate(180deg);
      }
      100% { 
        transform: scale(1);
        filter: brightness(1);
      }
    }

    @keyframes heal {
      0% { 
        transform: scale(1);
        filter: brightness(1);
      }
      50% { 
        transform: scale(1.05);
        filter: brightness(1.3) hue-rotate(120deg);
      }
      100% { 
        transform: scale(1);
        filter: brightness(1);
      }
    }

    @keyframes victory {
      0% { 
        transform: scale(1) rotate(0deg);
      }
      25% { 
        transform: scale(1.1) rotate(5deg);
      }
      50% { 
        transform: scale(1.2) rotate(-5deg);
      }
      75% { 
        transform: scale(1.1) rotate(5deg);
      }
      100% { 
        transform: scale(1) rotate(0deg);
      }
    }

    @keyframes purchase {
      0% { 
        transform: scale(1);
        filter: brightness(1);
      }
      25% { 
        transform: scale(1.05);
        filter: brightness(1.2);
      }
      50% { 
        transform: scale(1.1);
        filter: brightness(1.4);
      }
      75% { 
        transform: scale(1.05);
        filter: brightness(1.2);
      }
      100% { 
        transform: scale(1);
        filter: brightness(1);
      }
    }

    @keyframes synergyPulse {
      0%, 100% { 
        background: #d4edda;
        transform: scale(1);
      }
      50% { 
        background: #c3e6cb;
        transform: scale(1.05);
      }
    }

    /* Animation classes */
    .animate-fade-in {
      animation: fadeInUp 0.6s ease-out;
    }

    .animate-scale-in {
      animation: fadeInScale 0.5s ease-out;
    }

    .animate-slide-right {
      animation: slideInRight 0.5s ease-out;
    }

    .animate-slide-left {
      animation: slideInLeft 0.5s ease-out;
    }

    .animate-pulse {
      animation: pulse 2s infinite;
    }

    .animate-bounce {
      animation: bounce 1s ease-in-out;
    }

    .animate-shake {
      animation: shake 0.5s ease-in-out;
    }

    .animate-glow {
      animation: glow 2s infinite;
    }

    .animate-sparkle {
      animation: sparkle 1.5s ease-in-out;
    }

    .animate-damage {
      animation: damage 0.6s ease-in-out;
    }

    .animate-heal {
      animation: heal 0.8s ease-in-out;
    }

    .animate-victory {
      animation: victory 1s ease-in-out;
    }

    .animate-purchase {
      animation: purchase 1s ease-in-out;
    }

    .animate-synergy {
      animation: synergyPulse 1.5s ease-in-out;
    }

    /* Fusion animation styles */
    .fusion-animation {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      z-index: 1000;
      pointer-events: none;
    }

    .fusion-effect {
      background: linear-gradient(45deg, #ff6b6b, #4ecdc4, #45b7d1, #96ceb4);
      border-radius: 50%;
      width: 200px;
      height: 200px;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      animation: fusionPulse 2s ease-in-out;
      box-shadow: 0 0 50px rgba(255, 107, 107, 0.6);
    }

    .fusion-emoji {
      font-size: 4rem;
      margin-bottom: 10px;
      animation: fusionSpin 2s ease-in-out;
    }

    .fusion-text {
      font-size: 1.5rem;
      font-weight: bold;
      color: white;
      text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
      animation: fusionGlow 2s ease-in-out;
    }

    @keyframes fusionPulse {
      0% { transform: scale(0); opacity: 0; }
      50% { transform: scale(1.2); opacity: 1; }
      100% { transform: scale(1); opacity: 0; }
    }

    @keyframes fusionSpin {
      0% { transform: rotate(0deg) scale(0); }
      50% { transform: rotate(180deg) scale(1.2); }
      100% { transform: rotate(360deg) scale(1); }
    }

    @keyframes fusionGlow {
      0%, 100% { text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5); }
      50% { text-shadow: 0 0 20px rgba(255, 255, 255, 0.8); }
    }

    /* Staggered animations for lists */
    .stagger-animate > * {
      opacity: 0;
      animation: fadeInUp 0.5s ease-out forwards;
    }

    .stagger-animate > *:nth-child(1) { animation-delay: 0.1s; }
    .stagger-animate > *:nth-child(2) { animation-delay: 0.2s; }
    .stagger-animate > *:nth-child(3) { animation-delay: 0.3s; }
    .stagger-animate > *:nth-child(4) { animation-delay: 0.4s; }
    .stagger-animate > *:nth-child(5) { animation-delay: 0.5s; }
    .stagger-animate > *:nth-child(6) { animation-delay: 0.6s; }
    .stagger-animate > *:nth-child(7) { animation-delay: 0.7s; }
    .stagger-animate > *:nth-child(8) { animation-delay: 0.8s; }
    
    html, body {
      margin: 0;
      padding: 0;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen,
        Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
      background: #f5f5f5;
      color: #333;
      height: 100%;
    }

    #app {
      padding: 20px;
      box-sizing: border-box;
      min-height: 100vh;
      display: flex;
      flex-direction: column;
      align-items: stretch;
      animation: fadeInUp 0.8s ease-out;
    }

    /* Center content for start screen */
    .center-content {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      min-height: 80vh;
      text-align: center;
      animation: fadeInScale 1s ease-out;
    }

    /* Hero selection screen */
    .hero-selection {
      display: flex;
      flex-wrap: wrap;
      justify-content: center;
      gap: 20px;
      margin: 40px 0;
    }

    .hero-card {
      background: #ffffff;
      border-radius: 8px;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
      padding: 20px;
      width: 200px;
      cursor: pointer;
      transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
      display: flex;
      flex-direction: column;
      align-items: center;
      border: 2px solid transparent;
      animation: fadeInScale 0.6s ease-out;
    }

    .hero-card:hover {
      transform: scale(1.05) translateY(-5px);
      box-shadow: 0 8px 25px rgba(0, 0, 0, 0.15);
      border-color: #007bff;
    }

    .hero-card:active {
      transform: scale(0.98);
      transition: transform 0.1s ease;
    }

    .hero-emoji {
      font-size: 2.5rem;
      margin-bottom: 10px;
      transition: transform 0.3s ease;
    }

    .hero-card:hover .hero-emoji {
      transform: scale(1.1) rotate(5deg);
    }

    .hero-card h3 {
      margin: 10px 0;
      color: #007bff;
      transition: color 0.3s ease;
    }

    .hero-card:hover h3 {
      color: #0056b3;
    }

    .hero-card p {
      margin: 0;
      font-size: 0.9rem;
      color: #666;
      line-height: 1.4;
      transition: color 0.3s ease;
    }

    .hero-card:hover p {
      color: #333;
    }

    /* Game options */
    .game-options {
      margin-top: 20px;
      display: flex;
      gap: 10px;
    }

    /* Top bar */
    .top-bar {
      display: flex;
      justify-content: space-between;
      align-items: center;
      background: #ffffff;
      padding: 15px 20px;
      border-radius: 8px;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
      animation: slideInRight 0.6s ease-out;
    }

    .stats {
      display: flex;
      gap: 20px;
      flex-wrap: wrap;
    }

    .stats span {
      padding: 5px 10px;
      background: #f8f9fa;
      border-radius: 4px;
      font-size: 0.9rem;
      font-weight: 500;
      transition: all 0.3s ease;
      animation: fadeInUp 0.5s ease-out;
    }

    .stats span:hover {
      background: #e9ecef;
      transform: translateY(-2px);
    }

    .actions {
      display: flex;
      gap: 10px;
    }

    .button {
      background: #007bff;
      color: white;
      border: none;
      padding: 8px 16px;
      border-radius: 6px;
      cursor: pointer;
      font-size: 0.9rem;
      font-weight: 600;
      transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
      animation: fadeInScale 0.5s ease-out;
    }

    .button:hover:not(:disabled) {
      background: #0056b3;
      transform: translateY(-2px);
      box-shadow: 0 4px 12px rgba(0, 123, 255, 0.3);
    }

    .button:active:not(:disabled) {
      transform: translateY(0);
      transition: transform 0.1s ease;
    }

    .button:disabled {
      background: #6c757d;
      cursor: not-allowed;
      transform: none;
      box-shadow: none;
    }

    /* Board section */
    .board-section {
      background: #ffffff;
      border-radius: 8px;
      padding: 20px;
      margin-bottom: 20px;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
      animation: slideInLeft 0.6s ease-out;
    }

    .board-section h2 {
      margin: 0 0 15px 0;
      color: #007bff;
      animation: fadeInUp 0.5s ease-out;
    }

    .board {
      display: flex;
      gap: 15px;
      flex-wrap: wrap;
    }

    .board-slot {
      background: #f8f9fa;
      border: 2px dashed #dee2e6;
      border-radius: 8px;
      padding: 10px;
      min-width: 140px;
      min-height: 180px;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
      animation: fadeInScale 0.5s ease-out;
    }

    .board-slot:hover {
      border-color: #007bff;
      background: #f0f8ff;
      transform: scale(1.02);
    }

    .board-slot.selected {
      border-color: #28a745;
      background: #f8fff9;
      animation: glow 2s infinite;
    }

    .board-slot.fusion-ready {
      border-color: #ffc107;
      background: #fffbf0;
      animation: pulse 1.5s infinite;
    }

    .board-slot.occupied {
      border-style: solid;
      border-color: #28a745;
      background: #ffffff;
    }

    .board-slot.occupied:hover {
      transform: scale(1.05);
      box-shadow: 0 6px 20px rgba(0, 0, 0, 0.1);
    }

    /* Unit cards with enhanced animations */
    .unit-card {
      text-align: center;
      padding: 15px;
      border-radius: 8px;
      background: #ffffff;
      min-width: 140px;
      min-height: 180px;
      transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
      border: 2px solid #e9ecef;
      display: flex;
      flex-direction: column;
      justify-content: space-between;
      animation: fadeInScale 0.5s ease-out;
    }

    .unit-card:hover {
      transform: translateY(-5px) scale(1.02);
      box-shadow: 0 8px 25px rgba(0, 0, 0, 0.15);
      border-color: #007bff;
    }

    .unit-card:active {
      transform: translateY(-2px) scale(0.98);
      transition: transform 0.1s ease;
    }

    .shop-card {
      background: #f8f9fa;
      border: 2px solid #dee2e6;
      min-width: 160px;
      min-height: 200px;
    }

    .shop-card:hover {
      border-color: #28a745;
      background: #f8fff9;
      transform: translateY(-5px) scale(1.02);
      box-shadow: 0 8px 25px rgba(0, 0, 0, 0.15);
    }

    .unit-emoji {
      font-size: 2.5rem;
      margin-bottom: 8px;
      transition: transform 0.3s ease;
    }

    .unit-card:hover .unit-emoji {
      transform: scale(1.1) rotate(5deg);
    }

    .unit-name {
      font-weight: 700;
      font-size: 1.1rem;
      margin-bottom: 8px;
      color: #333;
      line-height: 1.2;
      transition: color 0.3s ease;
    }

    .unit-card:hover .unit-name {
      color: #007bff;
    }

    .unit-stats {
      font-size: 1.2rem;
      font-weight: 700;
      color: #333;
      margin-bottom: 8px;
      background: linear-gradient(45deg, #ff6b6b, #4ecdc4);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
      transition: all 0.3s ease;
    }

    .unit-card:hover .unit-stats {
      transform: scale(1.05);
    }

    .unit-ability {
      font-size: 0.8rem;
      color: #666;
      margin: 8px 0;
      padding: 6px;
      background: #f8f9fa;
      border-radius: 4px;
      border-left: 3px solid #007bff;
      text-align: left;
      line-height: 1.3;
      flex-grow: 1;
      display: flex;
      align-items: center;
      transition: all 0.3s ease;
    }

    .unit-card:hover .unit-ability {
      background: #e3f2fd;
      border-left-color: #2196f3;
      color: #1976d2;
    }

    .unit-class {
      font-size: 0.8rem;
      color: #007bff;
      font-weight: 600;
      margin-bottom: 4px;
      transition: color 0.3s ease;
    }

    .unit-card:hover .unit-class {
      color: #0056b3;
    }

    .unit-tier {
      font-size: 0.7rem;
      color: #6c757d;
      font-weight: 600;
      margin-top: 4px;
      padding: 2px 6px;
      border-radius: 3px;
      background: #f8f9fa;
      transition: all 0.3s ease;
    }

    .unit-card:hover .unit-tier {
      transform: scale(1.05);
    }

    .tier-1 {
      color: #28a745;
      background: #d4edda;
    }

    .tier-2 {
      color: #dc3545;
      background: #f8d7da;
    }

    .unit-cost {
      font-size: 1rem;
      color: #28a745;
      font-weight: 700;
      margin-bottom: 10px;
      transition: all 0.3s ease;
    }

    .shop-card:hover .unit-cost {
      transform: scale(1.1);
      color: #1e7e34;
    }

    .buy-btn {
      background: #28a745;
      color: white;
      border: none;
      padding: 8px 12px;
      border-radius: 6px;
      cursor: pointer;
      font-size: 0.9rem;
      font-weight: 600;
      width: 100%;
      transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
    }

    .buy-btn:hover:not(:disabled) {
      background: #1e7e34;
      transform: translateY(-2px);
      box-shadow: 0 4px 12px rgba(40, 167, 69, 0.3);
    }

    .buy-btn:active:not(:disabled) {
      transform: translateY(0);
      transition: transform 0.1s ease;
    }

    .buy-btn:disabled {
      background: #6c757d;
      cursor: not-allowed;
      transform: none;
      box-shadow: none;
    }

    /* Shop section with animations */
    .shop-section {
      background: #ffffff;
      border-radius: 8px;
      padding: 20px;
      margin-bottom: 20px;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
      animation: slideInRight 0.6s ease-out;
    }

    .shop-section h2 {
      margin: 0 0 15px 0;
      color: #007bff;
      animation: fadeInUp 0.5s ease-out;
    }

    .shop {
      display: flex;
      gap: 15px;
      flex-wrap: wrap;
    }

    .shop-slot {
      background: #f8f9fa;
      border-radius: 8px;
      padding: 10px;
      border: 1px solid #dee2e6;
      transition: all 0.3s ease;
      animation: fadeInScale 0.5s ease-out;
    }

    .shop-slot:hover {
      transform: translateY(-3px);
      box-shadow: 0 6px 20px rgba(0, 0, 0, 0.1);
    }

    /* Messages with animations */
    .message {
      background: #ffffff;
      border-radius: 8px;
      padding: 20px;
      margin-bottom: 20px;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
      animation: fadeInUp 0.6s ease-out;
    }

    .message h3 {
      margin: 0 0 10px 0;
      color: #007bff;
      animation: fadeInUp 0.5s ease-out;
    }

    .message-log {
      max-height: 150px;
      overflow-y: auto;
    }

    .message-item {
      padding: 8px 0;
      border-bottom: 1px solid #f0f0f0;
      font-size: 0.9rem;
      animation: slideInLeft 0.4s ease-out;
      transition: all 0.3s ease;
    }

    .message-item:hover {
      background: #f8f9fa;
      padding-left: 5px;
    }

    .message-item:last-child {
      border-bottom: none;
    }

    /* Battle screen animations */
    .battle-screen {
      background: #ffffff;
      border-radius: 8px;
      padding: 30px;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
      text-align: center;
      animation: fadeInScale 0.8s ease-out;
    }

    .battle-screen h1 {
      color: #dc3545;
      margin-bottom: 30px;
      animation: fadeInUp 0.6s ease-out;
    }

    .battle-armies {
      display: flex;
      justify-content: space-around;
      align-items: flex-start;
      margin: 30px 0;
      flex-wrap: wrap;
      gap: 20px;
    }

    .army {
      flex: 1;
      min-width: 300px;
      animation: slideInLeft 0.6s ease-out;
    }

    .army:nth-child(2) {
      animation: slideInRight 0.6s ease-out;
    }

    .army h3 {
      color: #007bff;
      margin-bottom: 15px;
      animation: fadeInUp 0.5s ease-out;
    }

    .army-units {
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
      justify-content: center;
    }

    .vs {
      font-size: 2rem;
      font-weight: bold;
      color: #dc3545;
      align-self: center;
    }

    .battle-log {
      background: #f8f9fa;
      border-radius: 8px;
      padding: 20px;
      margin: 30px 0;
      text-align: left;
    }

    .battle-log h3 {
      margin-top: 0;
      color: #007bff;
    }

    .log-content {
      max-height: 300px;
      overflow-y: auto;
      font-family: monospace;
      font-size: 0.9rem;
    }

    .log-entry {
      padding: 2px 0;
      border-bottom: 1px solid #e9ecef;
    }

    .log-entry:last-child {
      border-bottom: none;
    }

    .battle-results {
      margin: 20px 0;
      padding: 20px;
      background: #f8f9fa;
      border-radius: 8px;
      animation: fadeInUp 0.6s ease-out;
    }

    .battle-results p {
      margin: 8px 0;
      font-size: 1rem;
      animation: fadeInUp 0.4s ease-out;
    }

    .continue-btn {
      background: #28a745;
      color: white;
      border: none;
      padding: 12px 24px;
      border-radius: 6px;
      cursor: pointer;
      font-size: 1rem;
      font-weight: 600;
      margin-top: 20px;
      transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
      animation: fadeInScale 0.6s ease-out;
    }

    .continue-btn:hover {
      background: #1e7e34;
      transform: translateY(-2px);
      box-shadow: 0 4px 12px rgba(40, 167, 69, 0.3);
    }

    .continue-btn:active {
      transform: translateY(0);
      transition: transform 0.1s ease;
    }

    /* Game over screen */
    .game-over {
      text-align: center;
      padding: 40px;
      animation: fadeInScale 1s ease-out;
    }

    .game-over h1 {
      font-size: 2.5rem;
      margin-bottom: 20px;
      animation: victory 1s ease-in-out;
    }

    .game-over.win h1 {
      color: #28a745;
    }

    .game-over.lose h1 {
      color: #dc3545;
    }

    .game-over p {
      font-size: 1.2rem;
      margin-bottom: 30px;
      animation: fadeInUp 0.6s ease-out;
    }

    .restart-btn {
      background: #007bff;
      color: white;
      border: none;
      padding: 12px 24px;
      border-radius: 6px;
      cursor: pointer;
      font-size: 1rem;
      font-weight: 600;
      transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
      animation: fadeInScale 0.6s ease-out;
    }

    .restart-btn:hover {
      background: #0056b3;
      transform: translateY(-2px);
      box-shadow: 0 4px 12px rgba(0, 123, 255, 0.3);
    }

    .restart-btn:active {
      transform: translateY(0);
      transition: transform 0.1s ease;
    }

    /* Synergy sidebar animations */
    .synergy-sidebar {
      animation: slideInRight 0.8s ease-out;
    }

    .synergy-sidebar h3 { 
      margin-top: 0; 
      font-size: 1.1em; 
      animation: fadeInUp 0.5s ease-out;
    }

    .synergy-list { 
      list-style: none; 
      padding: 0; 
      margin: 0; 
    }

    .synergy-item { 
      margin-bottom: 8px; 
      padding: 8px 4px; 
      border-radius: 4px;
      transition: all 0.3s ease;
      animation: fadeInUp 0.4s ease-out;
    }

    .synergy-item:hover {
      background: #f8f9fa;
      transform: translateX(5px);
    }

    .synergy-item.active { 
      font-weight: bold; 
      color: #d2691e; 
      animation: synergyPulse 2s ease-in-out;
    }

    .synergy-bonus { 
      margin-left: 6px; 
      color: #388e3c; 
      font-size: 0.95em; 
      animation: fadeInUp 0.3s ease-out;
    }

    .synergy-next { 
      margin-left: 6px; 
      color: #888; 
      font-size: 0.92em; 
    }

    .synergy-name { 
      font-weight: bold; 
    }

    .synergy-count { 
      margin-left: 4px; 
    }

    /* Health bars with animations */
    .health-bar {
      width: 100%;
      height: 8px;
      background: #e9ecef;
      border-radius: 4px;
      overflow: hidden;
      margin: 5px 0;
    }

    .health-fill {
      height: 100%;
      background: linear-gradient(90deg, #dc3545, #ffc107, #28a745);
      transition: width 0.8s cubic-bezier(0.4, 0, 0.2, 1);
      animation: fadeInScale 0.5s ease-out;
    }

    .health-text {
      font-size: 0.8rem;
      color: #666;
      text-align: center;
      animation: fadeInUp 0.4s ease-out;
    }

    /* Empty slot animation */
    .empty-slot {
      color: #6c757d;
      font-size: 0.9rem;
      text-align: center;
      animation: fadeInScale 0.5s ease-out;
      transition: all 0.3s ease;
    }

    .empty-slot:hover {
      color: #007bff;
      transform: scale(1.05);
    }

    /* Achievement animations */
    .achievement {
      background: linear-gradient(45deg, #ffd700, #ffed4e);
      color: #333;
      padding: 15px;
      border-radius: 8px;
      margin: 10px 0;
      text-align: center;
      font-weight: bold;
      animation: victory 1s ease-in-out;
      box-shadow: 0 4px 12px rgba(255, 215, 0, 0.3);
    }

    /* Loading animations */
    .loading {
      display: inline-block;
      width: 20px;
      height: 20px;
      border: 3px solid #f3f3f3;
      border-top: 3px solid #007bff;
      border-radius: 50%;
      animation: spin 1s linear infinite;
    }

    .loading-spinner {
      width: 60px;
      height: 60px;
      border: 4px solid #f3f3f3;
      border-top: 4px solid #007bff;
      border-radius: 50%;
      animation: spin 1s linear infinite;
      margin: 20px auto;
    }

    @keyframes spin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }

    /* Responsive animations */
    @media (max-width: 768px) {
      .unit-card {
        min-width: 120px;
        min-height: 160px;
      }
      
      .shop-card {
        min-width: 140px;
        min-height: 180px;
      }
      
      .hero-card {
        width: 150px;
        padding: 15px;
      }
    }

    /* Visual Battle System */
    .battle-arena {
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      border-radius: 12px;
      padding: 30px;
      margin: 20px 0;
      position: relative;
      overflow: hidden;
      min-height: 400px;
    }

    .battle-field {
      display: flex;
      justify-content: space-between;
      align-items: center;
      position: relative;
      height: 300px;
    }

    .battle-side {
      display: flex;
      flex-direction: column;
      gap: 15px;
      align-items: center;
      width: 45%;
    }

    .battle-side.player {
      align-items: flex-start;
    }

    .battle-side.opponent {
      align-items: flex-end;
    }

    .battle-unit {
      background: rgba(255, 255, 255, 0.95);
      border-radius: 8px;
      padding: 12px;
      border: 2px solid #e9ecef;
      position: relative;
      transition: all 0.3s ease;
      min-width: 120px;
      text-align: center;
      box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
    }

    .battle-unit.active {
      border-color: #007bff;
      box-shadow: 0 0 20px rgba(0, 123, 255, 0.5);
      transform: scale(1.05);
    }

    .battle-unit.attacking {
      animation: attackMove 0.6s ease-in-out;
    }

    .battle-unit.taking-damage {
      animation: takeDamage 0.6s ease-in-out;
    }

    .battle-unit.dying {
      animation: unitDeath 1s ease-in-out forwards;
    }

    .battle-unit.defeated {
      opacity: 0.3;
      transform: scale(0.8);
    }

    .battle-unit-emoji {
      font-size: 2rem;
      margin-bottom: 5px;
    }

    .battle-unit-name {
      font-weight: 600;
      font-size: 0.9rem;
      margin-bottom: 5px;
    }

    .battle-unit-stats {
      font-size: 0.8rem;
      color: #666;
      margin-bottom: 8px;
    }

    .battle-health-bar {
      width: 100%;
      height: 6px;
      background: #e9ecef;
      border-radius: 3px;
      overflow: hidden;
      margin-bottom: 5px;
    }

    .battle-health-fill {
      height: 100%;
      background: linear-gradient(90deg, #dc3545, #ffc107, #28a745);
      transition: width 0.8s cubic-bezier(0.4, 0, 0.2, 1);
    }

    .battle-health-text {
      font-size: 0.7rem;
      color: #666;
      font-weight: 600;
    }

    .damage-number {
      position: absolute;
      font-weight: bold;
      font-size: 1.2rem;
      color: #dc3545;
      text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
      pointer-events: none;
      z-index: 10;
      animation: damageFloat 1s ease-out forwards;
    }

    .heal-number {
      position: absolute;
      font-weight: bold;
      font-size: 1.2rem;
      color: #28a745;
      text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
      pointer-events: none;
      z-index: 10;
      animation: healFloat 1s ease-out forwards;
    }

    .battle-center {
      position: absolute;
      left: 50%;
      top: 50%;
      transform: translate(-50%, -50%);
      font-size: 3rem;
      color: rgba(255, 255, 255, 0.8);
      z-index: 5;
    }

    .battle-progress {
      position: absolute;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(255, 255, 255, 0.9);
      padding: 10px 20px;
      border-radius: 20px;
      font-weight: 600;
      color: #333;
      box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
    }

    .battle-controls {
      display: flex;
      justify-content: center;
      gap: 15px;
      margin-top: 20px;
    }

    .battle-btn {
      background: #007bff;
      color: white;
      border: none;
      padding: 10px 20px;
      border-radius: 6px;
      cursor: pointer;
      font-weight: 600;
      transition: all 0.3s ease;
    }

    .battle-btn:hover:not(:disabled) {
      background: #0056b3;
      transform: translateY(-2px);
    }

    .battle-btn:disabled {
      background: #6c757d;
      cursor: not-allowed;
    }

    /* Battle Animation Keyframes */
    @keyframes attackMove {
      0% { transform: translateX(0) scale(1); }
      25% { transform: translateX(20px) scale(1.1); }
      50% { transform: translateX(40px) scale(1.05); }
      75% { transform: translateX(20px) scale(1.1); }
      100% { transform: translateX(0) scale(1); }
    }

    @keyframes takeDamage {
      0% { transform: scale(1); filter: brightness(1); }
      25% { transform: scale(1.1); filter: brightness(1.5) hue-rotate(0deg); }
      50% { transform: scale(0.9); filter: brightness(1.2) hue-rotate(180deg); }
      100% { transform: scale(1); filter: brightness(1); }
    }

    @keyframes unitDeath {
      0% { transform: scale(1) rotate(0deg); opacity: 1; }
      50% { transform: scale(1.2) rotate(180deg); opacity: 0.5; }
      100% { transform: scale(0) rotate(360deg); opacity: 0; }
    }

    @keyframes damageFloat {
      0% { 
        opacity: 1; 
        transform: translateY(0) scale(1);
      }
      100% { 
        opacity: 0; 
        transform: translateY(-50px) scale(1.5);
      }
    }

    @keyframes healFloat {
      0% { 
        opacity: 1; 
        transform: translateY(0) scale(1);
      }
      100% { 
        opacity: 0; 
        transform: translateY(-50px) scale(1.5);
      }
    }

    @keyframes battlePulse {
      0%, 100% { transform: scale(1); }
      50% { transform: scale(1.05); }
    }

    /* Battle screen animations */
    .battle-screen {
      background: #ffffff;
      border-radius: 8px;
      padding: 30px;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
      text-align: center;
      animation: fadeInScale 0.8s ease-out;
    }

    .battle-screen h1 {
      color: #dc3545;
      margin-bottom: 30px;
      animation: fadeInUp 0.6s ease-out;
    }

    .battle-results {
      margin: 20px 0;
      padding: 20px;
      background: #f8f9fa;
      border-radius: 8px;
      animation: fadeInUp 0.6s ease-out;
    }

    .battle-results p {
      margin: 8px 0;
      font-size: 1rem;
      animation: fadeInUp 0.4s ease-out;
    }

    .continue-btn {
      background: #28a745;
      color: white;
      border: none;
      padding: 12px 24px;
      border-radius: 6px;
      cursor: pointer;
      font-size: 1rem;
      font-weight: 600;
      margin-top: 20px;
      transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
      animation: fadeInScale 0.6s ease-out;
    }

    .continue-btn:hover {
      background: #1e7e34;
      transform: translateY(-2px);
      box-shadow: 0 4px 12px rgba(40, 167, 69, 0.3);
    }

    .continue-btn:active {
      transform: translateY(0);
      transition: transform 0.1s ease;
    }
  </style>
</head>
<body>
  <div id="app">
    <div class="center-content">
      <h1>🌟 Loading Elemental Battlegrounds... 🌟</h1>
      <div class="loading-spinner"></div>
      <p>Preparing your epic journey...</p>
    </div>
  </div>
  
  <!-- Background music (optional - remove if audio file doesn't exist) -->
  <audio id="bg-music" loop style="display: none;">
    <!-- You can add an audio source here if you have a music file -->
    <!-- <source src="background-music.mp3" type="audio/mpeg"> -->
  </audio>

  <script type="module">
    /**
     * Elemental Battlegrounds - Complete Offline Version with New Fusion System
     * Self-contained game with comprehensive unit system
     */

    // Import the new systems
    import { NEW_UNIT_DEFINITIONS, FUSION_MAP, BASE_TIER1_UNITS } from './new_unit_system.js';
    import { AbilitySystem } from './ability_system.js';
    import { FusionSystem } from './fusion_system.js';

    (() => {
      // ==================== CONSTANTS ====================
      
      // Use the new comprehensive unit definitions
      const unitDefinitions = NEW_UNIT_DEFINITIONS;
      
      // Use the new fusion system
      const fusionMaps = FUSION_MAP;
      
      // Initialize the new systems
      const abilitySystem = new AbilitySystem();
      const fusionSystem = new FusionSystem();

      const heroes = [
        {
          name: 'Relic of Strength', emoji: '💪',
          description: 'All your units gain +1 attack at the start of each battle.',
          ability: {
            roundStart: (player) => {},
            battleStart: (units) => { units.forEach(u => { u.attack += 1; }); }
          }
        },
        {
          name: 'Relic of Vitality', emoji: '❤️',
          description: 'Heal 1 health for your hero at the start of each round (up to max).',
          ability: {
            roundStart: (player) => {
              player.heroHealth = Math.min(player.heroMaxHealth, player.heroHealth + 1);
            },
            battleStart: (units) => {}
          }
        },
        {
          name: 'Relic of Fortitude', emoji: '🛡️',
          description: 'At the start of each battle, all your units gain +1 health.',
          ability: {
            roundStart: (player) => {},
            battleStart: (units) => {
              units.forEach(u => {
                u.health += 1;
                u.maxHealth = (u.maxHealth || u.health);
              });
            }
          }
        },
        {
          name: 'Relic of Prosperity', emoji: '💰',
          description: 'Gain +1 extra gold at the start of each round.',
          ability: {
            roundStart: (player) => { player.gold += 1; },
            battleStart: (units) => {}
          }
        }
      ];

      // Use the new base unit names from the fusion system
      let baseUnitNames = BASE_TIER1_UNITS;

      const GAME_CONFIG = {
        INITIAL_GOLD: 3,
        SHOP_SIZE: 5,
        INITIAL_BOARD_LIMIT: 5,
        INITIAL_HERO_HEALTH: 30,
        OPPONENT_HEALTH: 50,
        REROLL_COST: 1,
        UNIT_BASE_COST: 3,
        GOLD_PER_ROUND: 3, // Base gold per round, scales by +1 each round
        MAX_ROUNDS: 20
      };

      // Synergy Configuration
      const SYNERGY_CONFIG = {
        'Fire': [
          { count: 3, desc: '+1 Attack to all Fire units', effect: (board) => {
            board.forEach(u => {
              if (u.class === 'Elemental' && u.elements && u.elements.includes('Fire')) {
                u.attack += 1;
              }
            });
          }},
          { count: 5, desc: '+2 Attack to all Fire units', effect: (board) => {
            board.forEach(u => {
              if (u.class === 'Elemental' && u.elements && u.elements.includes('Fire')) {
                u.attack += 2;
              }
            });
          }}
        ],
        'Tech': [
          { count: 3, desc: '+1 Health to all Tech units', effect: (board) => {
            board.forEach(u => {
              if (u.class === 'Tech') {
                u.health += 1;
                u.maxHealth = (u.maxHealth || u.health);
              }
            });
          }},
          { count: 5, desc: '+2 Health to all Tech units', effect: (board) => {
            board.forEach(u => {
              if (u.class === 'Tech') {
                u.health += 2;
                u.maxHealth = (u.maxHealth || u.health);
              }
            });
          }}
        ],
        'Water': [
          { count: 3, desc: 'All Water units heal 1 HP after battle', effect: (board) => {
            board.forEach(u => {
              if (u.class === 'Elemental' && u.elements && u.elements.includes('Water')) {
                u.afterBattleHealthBonus = (u.afterBattleHealthBonus || 0) + 1;
              }
            });
          }}
        ],
        'Earth': [
          { count: 3, desc: '+1 Defense to all Earth units', effect: (board) => {
            board.forEach(u => {
              if (u.class === 'Elemental' && u.elements && u.elements.includes('Earth')) {
                u.reduceIncomingAttack = (u.reduceIncomingAttack || 0) + 1;
              }
            });
          }}
        ],
        'Air': [
          { count: 3, desc: '+1 Attack to all Air units', effect: (board) => {
            board.forEach(u => {
              if (u.class === 'Elemental' && u.elements && u.elements.includes('Air')) {
                u.attack += 1;
              }
            });
          }}
        ]
      };

      function getSynergyCounts(board) {
        const counts = {};
        board.forEach(unit => {
          if (unit.class) {
            counts[unit.class] = (counts[unit.class] || 0) + 1;
          }
          if (unit.elements) {
            unit.elements.forEach(element => {
              counts[element] = (counts[element] || 0) + 1;
            });
          }
        });
        return counts;
      }

      function getActiveSynergies(board) {
        const counts = getSynergyCounts(board);
        const active = [];
        for (const key in SYNERGY_CONFIG) {
          const list = SYNERGY_CONFIG[key];
          if (!list) continue;
          for (let i = list.length - 1; i >= 0; i--) {
            if (counts[key] >= list[i].count) {
              active.push({
                key,
                count: counts[key],
                threshold: list[i].count,
                desc: list[i].desc,
                effect: list[i].effect,
                next: list[i + 1] ? list[i + 1].count : null
              });
              break;
            }
          }
        }
        return { counts, active };
      }

      function applySynergies(board) {
        // Apply all synergy effects to the board (in-place)
        const { active } = getActiveSynergies(board);
        active.forEach(syn => syn.effect(board));
      }

      // ==================== GAME STATE ====================

      const state = {
        players: [],
        playerCount: 1,
        round: 1,
        currentPlayerIndex: 0,
        isShopPhase: true,
        gameOver: false,
        messageLog: [],
        selectedIndices: [],
        numHumans: 1,
        selectedRelics: [],
        heroHealth: GAME_CONFIG.INITIAL_HERO_HEALTH,
        heroMaxHealth: GAME_CONFIG.INITIAL_HERO_HEALTH,
        opponentHealth: GAME_CONFIG.OPPONENT_HEALTH,
        opponentMaxHealth: GAME_CONFIG.OPPONENT_HEALTH,
        gameStats: {
          roundsPlayed: 0,
          battlesWon: 0,
          battlesLost: 0,
          unitsBought: 0,
          fusionsCreated: 0,
          totalDamageDealt: 0,
          totalDamageReceived: 0,
          achievements: []
        }
      };

      // ==================== UTILITY FUNCTIONS ====================

      function getCurrentPlayer() {
        return state.players[state.currentPlayerIndex] || state.players[0];
      }

      function createPlayer(isHuman = true, heroData = null) {
        return {
          isHuman,
          heroName: heroData?.name || 'Unknown Hero',
          heroEmoji: heroData?.emoji || '❓',
          heroAbility: heroData?.ability || null,
          heroHealth: GAME_CONFIG.INITIAL_HERO_HEALTH,
          heroMaxHealth: GAME_CONFIG.INITIAL_HERO_HEALTH,
          gold: GAME_CONFIG.INITIAL_GOLD,
          board: [],
          shop: [],
          boardLimit: GAME_CONFIG.INITIAL_BOARD_LIMIT
        };
      }

      function addPlayer(player) {
        state.players.push(player);
      }

      function addMessage(text) {
        state.messageLog.push(text);
        if (state.messageLog.length > 10) {
          state.messageLog.shift();
        }
      }

      function checkAchievements() {
        const stats = state.gameStats;
        const achievements = [
          { id: 'first_fusion', name: 'First Fusion', condition: () => stats.fusionsCreated >= 1, earned: false },
          { id: 'fusion_master', name: 'Fusion Master', condition: () => stats.fusionsCreated >= 10, earned: false },
          { id: 'damage_dealer', name: 'Damage Dealer', condition: () => stats.totalDamageDealt >= 100, earned: false },
          { id: 'survivor', name: 'Survivor', condition: () => stats.roundsPlayed >= 10, earned: false },
          { id: 'victory', name: 'Victory', condition: () => stats.battlesWon >= 1, earned: false }
        ];

        achievements.forEach(achievement => {
          if (!stats.achievements.includes(achievement.id) && achievement.condition()) {
            stats.achievements.push(achievement.id);
            showAchievement(achievement.name);
          }
        });
      }

      function showAchievement(name) {
        const achievementDiv = document.createElement('div');
        achievementDiv.className = 'achievement';
        achievementDiv.innerHTML = `🏆 Achievement Unlocked: ${name}! 🏆`;
        document.body.appendChild(achievementDiv);
        
        setTimeout(() => {
          achievementDiv.remove();
        }, 3000);
      }

      function updateBoardLimit(player) {
        if (!player) return;
        let bonus = 0;
        player.board.forEach(unit => {
          if (unit && unit.boardLimitBonus) {
            bonus += unit.boardLimitBonus;
          }
        });
        player.boardLimit = GAME_CONFIG.INITIAL_BOARD_LIMIT + bonus;
      }

      function clearSelection() {
        state.selectedIndices = [];
      }

      // ==================== AUDIO SYSTEM ====================

      let audioVolume = 0.3;

      function initAudioVolume() {
        try {
          const saved = localStorage.getItem('audioVolume');
          if (saved !== null) {
            audioVolume = parseFloat(saved);
            if (isNaN(audioVolume) || audioVolume < 0 || audioVolume > 1) {
              audioVolume = 0.3;
            }
          }
        } catch (err) {
          console.warn('Failed to load audio volume:', err);
          audioVolume = 0.3;
        }
      }

      function playSound(type) {
        if (audioVolume <= 0) return;
        
        try {
          const audioContext = new (window.AudioContext || window.webkitAudioContext)();
          const oscillator = audioContext.createOscillator();
          const gainNode = audioContext.createGain();
          
          oscillator.connect(gainNode);
          gainNode.connect(audioContext.destination);
          
          gainNode.gain.setValueAtTime(audioVolume * 0.1, audioContext.currentTime);
          gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.1);
          
          let frequency = 440;
          switch (type) {
            case 'click': frequency = 800; break;
            case 'buy': frequency = 660; break;
            case 'fusion': frequency = 880; break;
            case 'battle': frequency = 220; break;
            case 'win': frequency = 1100; break;
            case 'lose': frequency = 150; break;
          }
          
          oscillator.frequency.setValueAtTime(frequency, audioContext.currentTime);
          oscillator.type = 'sine';
          
          oscillator.start(audioContext.currentTime);
          oscillator.stop(audioContext.currentTime + 0.1);
          
        } catch (err) {
          console.warn('Audio not supported:', err);
        }
      }

      function startBackgroundMusic() {
        const bgMusic = document.getElementById('bg-music');
        if (bgMusic && audioVolume > 0) {
          bgMusic.volume = audioVolume;
          bgMusic.play().catch(err => {
            console.warn('Failed to play background music:', err);
          });
        }
      }

      // ==================== UNITS MANAGEMENT ====================

      function createUnit(name) {
        const def = NEW_UNIT_DEFINITIONS[name];
        if (!def) {
          console.warn(`Unit definition not found: ${name}`);
          return null;
        }
        
        const unit = {
          name,
          attack: def.attack,
          health: def.health,
          maxHealth: def.health,
          emoji: def.emoji,
          class: def.class,
          elements: [...(def.elements || [])],
          tier: def.tier || 1
        };
        
        // Initialize abilities using the new ability system
        abilitySystem.initializeUnitAbilities(unit, def);
        
        return unit;
      }

      function getUnitCost(name) {
        const def = NEW_UNIT_DEFINITIONS[name];
        if (!def) return GAME_CONFIG.UNIT_BASE_COST;
        
        // Use tier-based cost system
        return fusionSystem.getUnitCost(def.tier || 1);
      }

      function attemptFusion(unit1, unit2) {
        if (!unit1 || !unit2) return null;
        
        // Use the new fusion system
        const resultDef = fusionSystem.getFusionResult(unit1, unit2);
        
        if (resultDef) {
          // Return the name of the fused unit
          return Object.keys(NEW_UNIT_DEFINITIONS).find(key => 
            NEW_UNIT_DEFINITIONS[key] === resultDef
          );
        }
        
        return null;
      }

      function createFusionDefinition(resultName, unitA, unitB) {
        const defA = NEW_UNIT_DEFINITIONS[unitA];
        const defB = NEW_UNIT_DEFINITIONS[unitB];
        
        if (!defA || !defB) return;
        
        const attack = defA.attack + defB.attack;
        const health = defA.health + defB.health;
        const emoji = defA.emoji + defB.emoji;
        const elements = [...(defA.elements || []), ...(defB.elements || [])];
        
        NEW_UNIT_DEFINITIONS[resultName] = {
          class: defA.class,
          attack,
          health,
          emoji,
          elements,
          tier: 2 // Fusion units are tier 2
        };
        
        if (!BASE_TIER1_UNITS.includes(resultName)) {
          BASE_TIER1_UNITS.push(resultName);
        }
      }

      function getRandomUnitName() {
        return BASE_TIER1_UNITS[Math.floor(Math.random() * BASE_TIER1_UNITS.length)];
      }

      function getTier1Units() {
        return Object.keys(NEW_UNIT_DEFINITIONS).filter(name => NEW_UNIT_DEFINITIONS[name].tier === 1);
      }

      function generateShop() {
        // Use the new fusion system to generate shop
        return fusionSystem.generateShop(state.player, GAME_CONFIG.SHOP_SIZE);
      }

      function refreshShopForPlayer(player) {
        player.shop = generateShop();
      }

      // ==================== BATTLE SYSTEM ====================

      function simulateBattle(playerUnits, opponentUnits, playerAbility = null, opponentAbility = null) {
        const log = [];
        let playerHeal = 0;
        let opponentHeal = 0;
        
        const pUnits = playerUnits.map(u => ({ ...u }));
        const oUnits = opponentUnits.map(u => ({ ...u }));
        
        // Apply start of combat abilities using the new ability system
        abilitySystem.applyStartOfCombatAbilities({ board: pUnits }, { board: oUnits });
        
        if (playerAbility && typeof playerAbility.battleStart === 'function') {
          playerAbility.battleStart(pUnits);
        }
        
        const applyPreBattle = (units, opponentUnits, side) => {
          let totalShield = 0;
          units.forEach(u => {
            if (u.startAttackBonus) {
              u.attack += u.startAttackBonus;
            }
            if (u.healHero) {
              if (side === 'player') playerHeal += u.healHero;
              else opponentHeal += u.healHero;
            }
            if (u.reduceIncomingAttackAll) {
              totalShield += u.reduceIncomingAttackAll;
            }
          });
          
          if (totalShield > 0) {
            units.forEach(u => {
              u.reduceIncomingAttack = (u.reduceIncomingAttack || 0) + totalShield;
            });
          }
          
          units.forEach(u => {
            if (u.aoeDamage) {
              opponentUnits.forEach(v => {
                v.health -= u.aoeDamage;
              });
              if (u.aoeDamage > 0) {
                log.push(`${u.name} deals ${u.aoeDamage} damage to all enemies!`);
              }
            }
          });
        };
        
        applyPreBattle(pUnits, oUnits, 'player');
        applyPreBattle(oUnits, pUnits, 'opponent');
        
        // Remove dead units
        function purgeDead(arr) {
          for (let i = arr.length - 1; i >= 0; i--) {
            if (arr[i].health <= 0) {
              log.push(`${arr[i].name} is destroyed before combat.`);
              arr.splice(i, 1);
            }
          }
        }
        purgeDead(pUnits);
        purgeDead(oUnits);
        
        // Battle loop
        let roundCounter = 1;
        while (pUnits.length > 0 && oUnits.length > 0) {
          const p = pUnits[0];
          const o = oUnits[0];
          log.push(`Round ${roundCounter}: ${p.name} (${p.attack}/${p.health}) vs ${o.name} (${o.attack}/${o.health})`);
          
          while (p.health > 0 && o.health > 0) {
            const pToO = Math.max(0, p.attack - (o.reduceIncomingAttack || 0));
            const oToP = Math.max(0, o.attack - (p.reduceIncomingAttack || 0));
            
            p.health -= oToP;
            o.health -= pToO;
            
            if (p.burnEffect && oToP > 0) {
              o.health -= p.burnEffect;
            }
            if (o.burnEffect && pToO > 0) {
              p.health -= o.burnEffect;
            }
            
            if (p.health <= 0 || o.health <= 0) break;
          }
          
          const pDead = p.health <= 0;
          const oDead = o.health <= 0;
          if (pDead && oDead) {
            log.push(`Both ${p.name} and ${o.name} are defeated!`);
            pUnits.shift();
            oUnits.shift();
          } else if (pDead) {
            log.push(`${p.name} dies; ${o.name} survives with ${Math.max(0, o.health)} HP.`);
            if (o.gainAttackOnKill) {
              o.attack += o.gainAttackOnKill;
            }
            pUnits.shift();
          } else if (oDead) {
            log.push(`${o.name} dies; ${p.name} survives with ${Math.max(0, p.health)} HP.`);
            if (p.gainAttackOnKill) {
              p.attack += p.gainAttackOnKill;
            }
            oUnits.shift();
          }
          roundCounter++;
        }
        
        // Apply end of combat abilities using the new ability system
        abilitySystem.applyEndOfCombatAbilities({ board: pUnits }, { board: oUnits });
        
        // After battle effects
        const applyAfterBattle = (units) => {
          units.forEach(u => {
            if (u.afterBattleHealthBonus) {
              u.health += u.afterBattleHealthBonus;
              u.maxHealth = (u.maxHealth || u.health);
            }
          });
        };
        applyAfterBattle(pUnits);
        applyAfterBattle(oUnits);
        
        return { playerSurvivors: pUnits, opponentSurvivors: oUnits, log, playerHeal, opponentHeal };
      }

      function computeDamageFromUnits(units) {
        return units.reduce((total, u) => {
          let dmg = 0;
          const def = NEW_UNIT_DEFINITIONS[u.name];
          if (def && def.elements) {
            dmg = Math.max(0, def.elements.length - 1);
          }
          if (u.survivorDamageBonus) {
            dmg += u.survivorDamageBonus;
          }
          return total + dmg;
        }, 0);
      }

      function generateOpponent(round = 1) {
        const opponent = [];
        const baseUnits = Math.min(3 + Math.floor(round / 2), 8);
        const fusedUnits = Math.floor(round / 3);
        const eliteUnits = Math.floor(round / 5);
        
        // Base units with scaling
        for (let i = 0; i < baseUnits; i++) {
          const unitName = getRandomUnitName();
          const unit = createUnit(unitName);
          if (unit) {
            // Scale units with round
            unit.attack += Math.floor(round / 3);
            unit.health += Math.floor(round / 4);
            unit.maxHealth = unit.health;
            opponent.push(unit);
          }
        }
        
        // Fused units
        for (let i = 0; i < fusedUnits; i++) {
          const unitName = getRandomUnitName();
          const unit = createUnit(unitName);
          if (unit) {
            unit.attack += round * 2;
            unit.health += round * 2;
            unit.maxHealth = unit.health;
            unit.name += ' Elite';
            opponent.push(unit);
          }
        }
        
        // Boss units every 5 rounds
        for (let i = 0; i < eliteUnits; i++) {
          const unitName = getRandomUnitName();
          const unit = createUnit(unitName);
          if (unit) {
            unit.attack += round * 3;
            unit.health += round * 3;
            unit.maxHealth = unit.health;
            unit.name += ' Boss';
            opponent.push(unit);
          }
        }
        
        return opponent;
      }

      // ==================== UI RENDERING ====================

      function renderUnitCard(unit) {
        const tier = NEW_UNIT_DEFINITIONS[unit.name]?.tier || 1;
        const ability = fusionSystem.getUnitDescription(unit);
        const hasAbility = ability && ability !== '';
        
        return `
          <div class="unit-card">
            <div class="unit-emoji">${unit.emoji}</div>
            <div class="unit-name">${unit.name}</div>
            <div class="unit-stats">⚔️${unit.attack} ❤️${unit.health}</div>
            ${unit.class ? `<div class="unit-class">${unit.class}</div>` : ''}
            ${hasAbility ? `<div class="unit-ability">${ability}</div>` : ''}
            <div class="unit-tier tier-${tier}">Tier ${tier}</div>
          </div>
        `;
      }

      function renderStartScreen() {
        const app = document.getElementById('app');
        app.innerHTML = `
          <div class="center-content">
            <h1>🌟 Elemental Battlegrounds 🌟</h1>
            <p>Choose your relic to begin your journey!</p>
            <div class="hero-selection">
              ${heroes.map(hero => `
                <div class="hero-card" onclick="selectHero('${hero.name}')">
                  <div class="hero-emoji">${hero.emoji}</div>
                  <h3>${hero.name}</h3>
                  <p>${hero.description}</p>
                </div>
              `).join('')}
            </div>
          </div>
        `;
      }

      function renderGameScreen() {
        const app = document.getElementById('app');
        const player = getCurrentPlayer();
        updateBoardLimit(player);
        app.innerHTML = '';
        
        // Top bar
        const topBar = document.createElement('div');
        topBar.className = 'top-bar';
        
        const stats = document.createElement('div');
        stats.className = 'stats';
        const nextGoldGain = GAME_CONFIG.GOLD_PER_ROUND + state.round;
        stats.innerHTML = `
          <span>💪 ${player.heroEmoji} HP: ${player.heroHealth}/${player.heroMaxHealth}</span>
          <span>💰 Gold: ${player.gold}</span>
          <span>⚔️ Round: ${state.round}/${GAME_CONFIG.MAX_ROUNDS}</span>
          <span>🎯 Opponent: ${state.opponentHealth}/${state.opponentMaxHealth}</span>
          <span>💎 Next: +${nextGoldGain} gold</span>
        `;
        
        const actions = document.createElement('div');
        actions.className = 'actions';
        
        const rerollBtn = document.createElement('button');
        rerollBtn.className = 'button';
        rerollBtn.innerText = 'Reroll (1 gold)';
        rerollBtn.disabled = player.gold < 1;
        rerollBtn.addEventListener('click', () => {
          if (player.gold >= 1) {
            // Add click animation
            rerollBtn.classList.add('animate-bounce');
            setTimeout(() => rerollBtn.classList.remove('animate-bounce'), 600);
            
            player.gold -= 1;
            refreshShopForPlayer(player);
            updateGameDisplay();
            playSound('click');
          }
        });
        
        const battleBtn = document.createElement('button');
        battleBtn.className = 'button battle-btn';
        battleBtn.innerText = 'Battle!';
        battleBtn.disabled = player.board.length === 0 || state.gameOver;
        battleBtn.addEventListener('click', () => {
          if (state.gameOver) return;
          // Add click animation
          battleBtn.classList.add('animate-bounce');
          setTimeout(() => battleBtn.classList.remove('animate-bounce'), 600);
          
          doBattle();
          playSound('click');
        });
        
        const statsBtn = document.createElement('button');
        statsBtn.className = 'button';
        statsBtn.innerText = 'Stats';
        statsBtn.addEventListener('click', () => {
          // Add click animation
          statsBtn.classList.add('animate-bounce');
          setTimeout(() => statsBtn.classList.remove('animate-bounce'), 600);
          
          showStats();
          playSound('click');
        });
        
        const saveBtn = document.createElement('button');
        saveBtn.className = 'button';
        saveBtn.innerText = 'Save';
        saveBtn.addEventListener('click', () => {
          // Add click animation
          saveBtn.classList.add('animate-bounce');
          setTimeout(() => saveBtn.classList.remove('animate-bounce'), 600);
          
          saveGame();
          playSound('click');
        });
        
        const loadBtn = document.createElement('button');
        loadBtn.className = 'button';
        loadBtn.innerText = 'Load';
        loadBtn.addEventListener('click', () => {
          // Add click animation
          loadBtn.classList.add('animate-bounce');
          setTimeout(() => loadBtn.classList.remove('animate-bounce'), 600);
          
          loadGame();
          playSound('click');
        });
        
        actions.appendChild(rerollBtn);
        actions.appendChild(battleBtn);
        actions.appendChild(statsBtn);
        actions.appendChild(saveBtn);
        actions.appendChild(loadBtn);
        topBar.appendChild(stats);
        topBar.appendChild(actions);
        app.appendChild(topBar);
        
        // Board section
        const boardSection = document.createElement('div');
        boardSection.className = 'board-section';
        boardSection.innerHTML = `<h2>Your Board (${player.board.length}/${player.boardLimit})</h2>`;
        
        const board = document.createElement('div');
        board.className = 'board';
        
        for (let i = 0; i < player.boardLimit; i++) {
          const slot = document.createElement('div');
          slot.className = 'board-slot';
          slot.dataset.index = i;
          
          if (player.board[i]) {
            const unit = player.board[i];
            slot.innerHTML = renderUnitCard(unit);
            slot.classList.add('occupied');
            
            // Add selection highlighting
            if (state.selectedIndices.includes(i)) {
              slot.classList.add('selected');
            }
            
            // Add fusion-ready highlighting
            if (state.selectedIndices.length === 1 && state.selectedIndices[0] !== i) {
              const selectedUnit = player.board[state.selectedIndices[0]];
              if (selectedUnit && selectedUnit.class === unit.class) {
                slot.classList.add('fusion-ready');
              }
            }
          } else {
            slot.innerHTML = '<div class="empty-slot">Empty</div>';
          }
          
          slot.addEventListener('click', () => handleBoardClick(i));
          board.appendChild(slot);
        }
        
        boardSection.appendChild(board);
        app.appendChild(boardSection);
        
        // Shop section
        const shopSection = document.createElement('div');
        shopSection.className = 'shop-section';
        shopSection.innerHTML = '<h2>Shop <span style="font-size:0.8em;font-weight:normal;">(Reroll for 1 gold)</span></h2>';
        
        const shop = document.createElement('div');
        shop.className = 'shop';
        
        player.shop.forEach((unitName, index) => {
          const shopSlot = document.createElement('div');
          shopSlot.className = 'shop-slot';
          const unitDef = NEW_UNIT_DEFINITIONS[unitName];
          const ability = fusionSystem.getUnitDescription({ abilities: unitDef });
          const hasAbility = ability && ability !== '';
          
          shopSlot.innerHTML = `
            <div class="unit-card shop-card">
              <div class="unit-emoji">${unitDef.emoji}</div>
              <div class="unit-name">${unitName}</div>
              <div class="unit-stats">⚔️${unitDef.attack} ❤️${unitDef.health}</div>
              <div class="unit-class">${unitDef.class}</div>
              ${hasAbility ? `<div class="unit-ability">${ability}</div>` : ''}
              <div class="unit-tier tier-${unitDef.tier}">Tier ${unitDef.tier}</div>
              <div class="unit-cost">${getUnitCost(unitName)} gold</div>
              <button class="buy-btn" ${player.gold < getUnitCost(unitName) ? 'disabled' : ''} 
                      onclick="buyUnit(${index})">Buy</button>
            </div>
          `;
          shop.appendChild(shopSlot);
        });
        
        shopSection.appendChild(shop);
        app.appendChild(shopSection);
        
        // Messages
        renderMessage();

        // In the main game screen rendering, add a synergy sidebar
        const sidebar = document.createElement('div');
        sidebar.className = 'synergy-sidebar';
        const { counts, active } = getActiveSynergies(player.board);
        const allSynergies = Object.keys(SYNERGY_CONFIG);
        sidebar.innerHTML = `
          <h3>Synergies</h3>
          <ul class="synergy-list">
            ${allSynergies.map(syn => {
              const conf = SYNERGY_CONFIG[syn];
              const count = counts[syn] || 0;
              // Find next threshold
              let next = null, desc = '', activeDesc = '';
              for (let i = 0; i < conf.length; i++) {
                if (count < conf[i].count) {
                  next = conf[i].count;
                  desc = conf[i].desc;
                  break;
                } else {
                  activeDesc = conf[i].desc;
                }
              }
              const isActive = conf.some(c => count >= c.count);
              return `<li class="synergy-item${isActive ? ' active' : ''}">
                <span class="synergy-name">${syn}</span>: 
                <span class="synergy-count">${count}</span>
                ${isActive ? `<span class="synergy-bonus">${activeDesc}</span>` : next ? `<span class="synergy-next">(${next - count} to ${desc})</span>` : ''}
              </li>`;
            }).join('')}
          </ul>
        `;
        sidebar.style.position = 'fixed';
        sidebar.style.right = '0';
        sidebar.style.top = '80px';
        sidebar.style.width = '220px';
        sidebar.style.background = '#fff';
        sidebar.style.borderLeft = '2px solid #eee';
        sidebar.style.padding = '16px 12px';
        sidebar.style.zIndex = '100';
        sidebar.style.boxShadow = '0 2px 8px rgba(0,0,0,0.07)';
        sidebar.style.borderRadius = '8px 0 0 8px';
        sidebar.style.fontSize = '1em';
        sidebar.style.maxHeight = '60vh';
        sidebar.style.overflowY = 'auto';
        document.body.appendChild(sidebar);
      }

      function updateGameDisplay() {
        const player = getCurrentPlayer();
        if (!player) return;
        
        console.log(`updateGameDisplay called - Board length: ${player.board.length}, Game over: ${state.gameOver}`);
        
        // Update stats in top bar
        const statsElement = document.querySelector('.stats');
        if (statsElement) {
          const nextGoldGain = GAME_CONFIG.GOLD_PER_ROUND + state.round;
          statsElement.innerHTML = `
            <span>💪 ${player.heroEmoji} HP: ${player.heroHealth}/${player.heroMaxHealth}</span>
            <span>💰 Gold: ${player.gold}</span>
            <span>⚔️ Round: ${state.round}/${GAME_CONFIG.MAX_ROUNDS}</span>
            <span>🎯 Opponent: ${state.opponentHealth}/${state.opponentMaxHealth}</span>
            <span>💎 Next: +${nextGoldGain} gold</span>
          `;
        }
        
        // Update board section
        const boardSection = document.querySelector('.board-section h2');
        if (boardSection) {
          boardSection.textContent = `Your Board (${player.board.length}/${player.boardLimit})`;
        }
        
        // Update board slots
        const boardSlots = document.querySelectorAll('.board-slot');
        boardSlots.forEach((slot, i) => {
          if (player.board[i]) {
            const unit = player.board[i];
            slot.innerHTML = renderUnitCard(unit);
            slot.classList.add('occupied');
            
            // Add selection highlighting
            if (state.selectedIndices.includes(i)) {
              slot.classList.add('selected');
            } else {
              slot.classList.remove('selected');
            }
            
            // Add fusion-ready highlighting
            if (state.selectedIndices.length === 1 && state.selectedIndices[0] !== i) {
              const selectedUnit = player.board[state.selectedIndices[0]];
              if (selectedUnit && selectedUnit.class === unit.class) {
                slot.classList.add('fusion-ready');
              } else {
                slot.classList.remove('fusion-ready');
              }
            } else {
              slot.classList.remove('fusion-ready');
            }
          } else {
            slot.innerHTML = '<div class="empty-slot">Empty</div>';
            slot.classList.remove('occupied', 'selected', 'fusion-ready');
          }
        });
        
        // Update shop buttons
        const buyButtons = document.querySelectorAll('.buy-btn');
        buyButtons.forEach((btn, index) => {
          const unitName = player.shop[index];
          if (unitName) {
            const cost = getUnitCost(unitName);
            btn.disabled = player.gold < cost;
          }
        });
        
        // Update battle button state
        const battleBtn = document.querySelector('.battle-btn');
        if (battleBtn) {
          const shouldDisable = player.board.length === 0 || state.gameOver;
          battleBtn.disabled = shouldDisable;
          console.log(`Battle button update: board length=${player.board.length}, gameOver=${state.gameOver}, disabled=${shouldDisable}`);
          
          // Add visual feedback
          if (shouldDisable) {
            battleBtn.title = 'No units on board';
          } else {
            battleBtn.title = 'Ready to battle!';
          }
        }
        
        // Update synergy sidebar
        const sidebar = document.querySelector('.synergy-sidebar');
        if (sidebar) {
          const { counts, active } = getActiveSynergies(player.board);
          const allSynergies = Object.keys(SYNERGY_CONFIG);
          sidebar.innerHTML = `
            <h3>Synergies</h3>
            <ul class="synergy-list">
              ${allSynergies.map(syn => {
                const conf = SYNERGY_CONFIG[syn];
                const count = counts[syn] || 0;
                // Find next threshold
                let next = null, desc = '', activeDesc = '';
                for (let i = 0; i < conf.length; i++) {
                  if (count < conf[i].count) {
                    next = conf[i].count;
                    desc = conf[i].desc;
                    break;
                  } else {
                    activeDesc = conf[i].desc;
                  }
                }
                const isActive = conf.some(c => count >= c.count);
                return `<li class="synergy-item${isActive ? ' active' : ''}">
                  <span class="synergy-name">${syn}</span>: 
                  <span class="synergy-count">${count}</span>
                  ${isActive ? `<span class="synergy-bonus">${activeDesc}</span>` : next ? `<span class="synergy-next">(${next - count} to ${desc})</span>` : ''}
                </li>`;
              }).join('')}
            </ul>
          `;
        }
        
        // Update messages
        renderMessage();
      }

      function renderMessage() {
        let messageDiv = document.querySelector('.message');
        if (!messageDiv) {
          messageDiv = document.createElement('div');
          messageDiv.className = 'message';
          document.getElementById('app').appendChild(messageDiv);
        }
        
        messageDiv.innerHTML = `
          <h3>Messages</h3>
          <div class="message-log">
            ${state.messageLog.map(msg => `<div class="message-item">${msg}</div>`).join('')}
          </div>
        `;
      }

      function renderBattleScreen(playerUnits, opponentUnits, logs, pDamage, oDamage, pHeal = 0, oHeal = 0) {
        // Remove any existing synergy sidebar
        const existingSidebar = document.querySelector('.synergy-sidebar');
        if (existingSidebar) {
          existingSidebar.remove();
        }
        
        const app = document.getElementById('app');
        app.innerHTML = `
          <div class="battle-screen">
            <h1>⚔️ Visual Battle ⚔️</h1>
            
            <div class="battle-arena">
              <div class="battle-field">
                <div class="battle-side player">
                  <h3>Your Army</h3>
                  ${playerUnits.map((unit, index) => `
                    <div class="battle-unit" data-unit-id="player-${index}">
                      <div class="battle-unit-emoji">${unit.emoji}</div>
                      <div class="battle-unit-name">${unit.name}</div>
                      <div class="battle-unit-stats">⚔️${unit.attack} ❤️${unit.health}</div>
                      <div class="battle-health-bar">
                        <div class="battle-health-fill" style="width: ${(unit.health / (unit.maxHealth || unit.health)) * 100}%"></div>
                      </div>
                      <div class="battle-health-text">${unit.health}/${unit.maxHealth || unit.health}</div>
                    </div>
                  `).join('')}
                </div>
                
                <div class="battle-center">⚔️</div>
                
                <div class="battle-side opponent">
                  <h3>Enemy Army</h3>
                  ${opponentUnits.map((unit, index) => `
                    <div class="battle-unit" data-unit-id="opponent-${index}">
                      <div class="battle-unit-emoji">${unit.emoji}</div>
                      <div class="battle-unit-name">${unit.name}</div>
                      <div class="battle-unit-stats">⚔️${unit.attack} ❤️${unit.health}</div>
                      <div class="battle-health-bar">
                        <div class="battle-health-fill" style="width: ${(unit.health / (unit.maxHealth || unit.health)) * 100}%"></div>
                      </div>
                      <div class="battle-health-text">${unit.health}/${unit.maxHealth || unit.health}</div>
                    </div>
                  `).join('')}
                </div>
              </div>
              
              <div class="battle-progress">
                Battle in Progress...
              </div>
            </div>
            
            <div class="battle-controls">
              <button class="battle-btn" onclick="startVisualBattle()">Start Battle</button>
              <button class="battle-btn" onclick="skipBattle()">Skip Battle</button>
            </div>
            
            <div class="battle-results" style="display: none;">
              <p>💥 Damage dealt to opponent: ${oDamage}</p>
              <p>💔 Damage received: ${pDamage}</p>
              ${pHeal > 0 ? `<p>💚 Health healed: ${pHeal}</p>` : ''}
              <p>🎯 Opponent Health:</p>
              <div class="health-bar">
                <div class="health-fill" style="width: ${(state.opponentHealth / state.opponentMaxHealth) * 100}%"></div>
              </div>
              <div class="health-text">${state.opponentHealth}/${state.opponentMaxHealth}</div>
              <p>💪 Your health: ${getCurrentPlayer().heroHealth}/${getCurrentPlayer().heroMaxHealth}</p>
            </div>
            
            <button class="continue-btn" onclick="finishBattle(${pDamage}, ${oDamage}, ${pHeal}, ${oHeal})" style="display: none;">
              Continue to Next Round
            </button>
          </div>
        `;
        
        // Store battle data for visual battle
        window.battleData = {
          playerUnits: playerUnits,
          opponentUnits: opponentUnits,
          pDamage: pDamage,
          oDamage: oDamage,
          pHeal: pHeal,
          oHeal: oHeal
        };
      }

      function startVisualBattle() {
        const battleData = window.battleData;
        if (!battleData) return;
        
        const playerUnits = [...battleData.playerUnits];
        const opponentUnits = [...battleData.opponentUnits];
        
        // Hide controls and show progress
        document.querySelector('.battle-controls').style.display = 'none';
        document.querySelector('.battle-progress').textContent = 'Battle Starting...';
        
        // Hide synergy sidebar during battle
        const sidebar = document.querySelector('.synergy-sidebar');
        if (sidebar) {
          sidebar.remove();
        }
        
        // Start visual battle sequence
        animateBattle(playerUnits, opponentUnits);
      }

      function animateBattle(playerUnits, opponentUnits) {
        let round = 1;
        const maxRounds = 20; // Prevent infinite loops
        
        // Apply synergies to player units before battle
        applySynergies(playerUnits);
        
        // Apply pre-battle effects
        applyPreBattle(playerUnits, opponentUnits, 'player');
        applyPreBattle(opponentUnits, playerUnits, 'opponent');
        
        // Remove dead units from pre-battle effects
        playerUnits = playerUnits.filter(unit => unit.health > 0);
        opponentUnits = opponentUnits.filter(unit => unit.health > 0);
        
        function battleStep() {
          if (round > maxRounds || playerUnits.length === 0 || opponentUnits.length === 0) {
            endBattle();
            return;
          }
          
          const playerUnit = playerUnits[0];
          const opponentUnit = opponentUnits[0];
          
          if (!playerUnit || !opponentUnit) {
            endBattle();
            return;
          }
          
          // Update progress
          document.querySelector('.battle-progress').textContent = `Round ${round}: ${playerUnit.name} vs ${opponentUnit.name}`;
          
          // Highlight active units
          highlightActiveUnits(playerUnit, opponentUnit);
          
          // Simulate combat with proper mechanics
          setTimeout(() => {
            const pToO = Math.max(0, playerUnit.attack - (opponentUnit.reduceIncomingAttack || 0));
            const oToP = Math.max(0, opponentUnit.attack - (playerUnit.reduceIncomingAttack || 0));
            
            // Apply damage with visual effects
            if (pToO > 0) {
              applyDamage(opponentUnit, pToO, 'opponent');
            }
            if (oToP > 0) {
              applyDamage(playerUnit, oToP, 'player');
            }
            
            // Apply burn effects
            if (playerUnit.burnEffect && oToP > 0) {
              setTimeout(() => {
                applyDamage(opponentUnit, playerUnit.burnEffect, 'opponent');
              }, 400);
            }
            if (opponentUnit.burnEffect && pToO > 0) {
              setTimeout(() => {
                applyDamage(playerUnit, opponentUnit.burnEffect, 'player');
              }, 400);
            }
            
            // Check for unit deaths and handle special abilities
            setTimeout(() => {
              const pDead = playerUnit.health <= 0;
              const oDead = opponentUnit.health <= 0;
              
              if (pDead && oDead) {
                // Both units die
                killUnit(playerUnit, 'player');
                killUnit(opponentUnit, 'opponent');
                playerUnits.shift();
                opponentUnits.shift();
              } else if (pDead) {
                // Player unit dies
                killUnit(playerUnit, 'player');
                if (opponentUnit.gainAttackOnKill) {
                  opponentUnit.attack += opponentUnit.gainAttackOnKill;
                  showAbilityEffect(opponentUnit, 'opponent', `+${opponentUnit.gainAttackOnKill} Attack`);
                }
                playerUnits.shift();
              } else if (oDead) {
                // Opponent unit dies
                killUnit(opponentUnit, 'opponent');
                if (playerUnit.gainAttackOnKill) {
                  playerUnit.attack += playerUnit.gainAttackOnKill;
                  showAbilityEffect(playerUnit, 'player', `+${playerUnit.gainAttackOnKill} Attack`);
                }
                opponentUnits.shift();
              }
              
              round++;
              setTimeout(battleStep, 1000);
            }, 800);
          }, 600);
        }
        
        battleStep();
      }

      function showAbilityEffect(unit, side, effect) {
        const unitElement = document.querySelector(`[data-unit-id="${side}-0"]`);
        if (!unitElement) return;
        
        const effectElement = document.createElement('div');
        effectElement.className = 'heal-number';
        effectElement.textContent = effect;
        effectElement.style.left = '50%';
        effectElement.style.top = '20%';
        effectElement.style.transform = 'translate(-50%, -50%)';
        
        unitElement.appendChild(effectElement);
        
        setTimeout(() => {
          effectElement.remove();
        }, 1000);
      }

      function applyPreBattle(units, enemyUnits, side) {
        units.forEach(unit => {
          // Start of combat abilities
          if (unit.startAttackBonus) {
            unit.attack += unit.startAttackBonus;
            showAbilityEffect(unit, side, `+${unit.startAttackBonus} Attack`);
          }
          if (unit.healHero) {
            // This would heal the hero, but we'll show it as a unit effect for now
            showAbilityEffect(unit, side, `Heal ${unit.healHero}`);
          }
        });
      }

      function highlightActiveUnits(playerUnit, opponentUnit) {
        // Remove previous highlights
        document.querySelectorAll('.battle-unit').forEach(unit => {
          unit.classList.remove('active');
        });
        
        // Highlight current fighters (first units in each array)
        const playerElement = document.querySelector(`[data-unit-id="player-0"]`);
        const opponentElement = document.querySelector(`[data-unit-id="opponent-0"]`);
        
        if (playerElement && playerUnit) {
          playerElement.classList.add('active');
        }
        if (opponentElement && opponentUnit) {
          opponentElement.classList.add('active');
        }
      }

      function applyDamage(unit, damage, side) {
        const unitElement = document.querySelector(`[data-unit-id="${side}-0"]`);
        if (!unitElement) return;
        
        // Add attack animation
        unitElement.classList.add('attacking');
        
        setTimeout(() => {
          // Apply damage
          unit.health = Math.max(0, unit.health - damage);
          
          // Update health bar
          const healthFill = unitElement.querySelector('.battle-health-fill');
          const healthText = unitElement.querySelector('.battle-health-text');
          const statsText = unitElement.querySelector('.battle-unit-stats');
          const maxHealth = unit.maxHealth || unit.health + damage;
          
          if (healthFill) {
            healthFill.style.width = `${(unit.health / maxHealth) * 100}%`;
          }
          if (healthText) {
            healthText.textContent = `${unit.health}/${maxHealth}`;
          }
          if (statsText) {
            statsText.textContent = `⚔️${unit.attack} ❤️${unit.health}`;
          }
          
          // Show damage number
          showDamageNumber(unitElement, damage);
          
          // Add damage animation
          unitElement.classList.add('taking-damage');
          
          setTimeout(() => {
            unitElement.classList.remove('attacking', 'taking-damage');
          }, 600);
        }, 300);
      }

      function showDamageNumber(unitElement, damage) {
        const damageNumber = document.createElement('div');
        damageNumber.className = 'damage-number';
        damageNumber.textContent = `-${damage}`;
        damageNumber.style.left = '50%';
        damageNumber.style.top = '50%';
        damageNumber.style.transform = 'translate(-50%, -50%)';
        
        unitElement.appendChild(damageNumber);
        
        setTimeout(() => {
          damageNumber.remove();
        }, 1000);
      }

      function killUnit(unit, side) {
        const unitElement = document.querySelector(`[data-unit-id="${side}-0"]`);
        if (!unitElement) return;
        
        unitElement.classList.add('dying');
        
        setTimeout(() => {
          unitElement.classList.add('defeated');
          unitElement.style.display = 'none';
          
          // Update remaining units' data-unit-id to maintain proper indexing
          const remainingUnits = document.querySelectorAll(`[data-unit-id^="${side}-"]`);
          remainingUnits.forEach((el, index) => {
            if (el !== unitElement) {
              el.setAttribute('data-unit-id', `${side}-${index}`);
            }
          });
        }, 1000);
      }

      function endBattle() {
        const battleData = window.battleData;
        if (!battleData) return;
        
        document.querySelector('.battle-progress').textContent = 'Battle Complete!';
        document.querySelector('.battle-results').style.display = 'block';
        document.querySelector('.continue-btn').style.display = 'inline-block';
      }

      function skipBattle() {
        const battleData = window.battleData;
        if (!battleData) return;
        
        // Show results immediately
        document.querySelector('.battle-controls').style.display = 'none';
        document.querySelector('.battle-progress').textContent = 'Battle Skipped';
        document.querySelector('.battle-results').style.display = 'block';
        document.querySelector('.continue-btn').style.display = 'inline-block';
        
        // Hide synergy sidebar during battle
        const sidebar = document.querySelector('.synergy-sidebar');
        if (sidebar) {
          sidebar.remove();
        }
      }

      function saveGame() {
        try {
          const saveData = {
            players: state.players,
            round: state.round,
            opponentHealth: state.opponentHealth,
            opponentMaxHealth: state.opponentMaxHealth,
            gameStats: state.gameStats,
            timestamp: Date.now()
          };
          localStorage.setItem('elementalBattlegroundsSave', JSON.stringify(saveData));
          addMessage('Game saved successfully!');
        } catch (err) {
          addMessage('Failed to save game: ' + err.message);
        }
      }

      function loadGame() {
        try {
          const saveData = localStorage.getItem('elementalBattlegroundsSave');
          if (!saveData) {
            addMessage('No saved game found!');
            return;
          }
          
          const data = JSON.parse(saveData);
          state.players = data.players;
          state.round = data.round;
          state.opponentHealth = data.opponentHealth;
          state.opponentMaxHealth = data.opponentMaxHealth;
          state.gameStats = data.gameStats;
          
          addMessage('Game loaded successfully!');
          renderGameScreen();
        } catch (err) {
          addMessage('Failed to load game: ' + err.message);
        }
      }

      function showStats() {
        const app = document.getElementById('app');
        const stats = state.gameStats;
        app.innerHTML = `
          <div class="game-over">
            <h1>📊 Game Statistics</h1>
            <div style="text-align: left; max-width: 400px; margin: 0 auto;">
              <p><strong>Rounds Played:</strong> ${stats.roundsPlayed}</p>
              <p><strong>Battles Won:</strong> ${stats.battlesWon}</p>
              <p><strong>Battles Lost:</strong> ${stats.battlesLost}</p>
              <p><strong>Units Bought:</strong> ${stats.unitsBought}</p>
              <p><strong>Fusions Created:</strong> ${stats.fusionsCreated}</p>
              <p><strong>Total Damage Dealt:</strong> ${stats.totalDamageDealt}</p>
              <p><strong>Total Damage Received:</strong> ${stats.totalDamageReceived}</p>
              <p><strong>Win Rate:</strong> ${stats.battlesWon + stats.battlesLost > 0 ? Math.round((stats.battlesWon / (stats.battlesWon + stats.battlesLost)) * 100) : 0}%</p>
            </div>
            <button class="button" onclick="renderGameScreen()">Back to Game</button>
          </div>
        `;
      }

      function renderGameOver(won) {
        const app = document.getElementById('app');
        const stats = state.gameStats;
        app.innerHTML = `
          <div class="game-over">
            <h1>${won ? '🎉 Victory!' : '💀 Defeat!'}</h1>
            <p>${won ? 'Congratulations! You have emerged victorious!' : 'Better luck next time, hero.'}</p>
            <div style="text-align: left; max-width: 400px; margin: 20px auto;">
              <h3>Final Statistics:</h3>
              <p><strong>Rounds Survived:</strong> ${stats.roundsPlayed}</p>
              <p><strong>Battles Won:</strong> ${stats.battlesWon}</p>
              <p><strong>Total Damage Dealt:</strong> ${stats.totalDamageDealt}</p>
              <p><strong>Fusions Created:</strong> ${stats.fusionsCreated}</p>
            </div>
            <button class="button" onclick="renderStartScreen()">Play Again</button>
          </div>
        `;
        
        playSound(won ? 'win' : 'lose');
      }

      function showFusionAnimation(emoji) {
        const animation = document.createElement('div');
        animation.className = 'fusion-animation';
        animation.innerHTML = `
          <div class="fusion-effect">
            <div class="fusion-emoji">${emoji}</div>
            <div class="fusion-text">FUSION!</div>
          </div>
        `;
        
        document.body.appendChild(animation);
        
        setTimeout(() => {
          animation.remove();
        }, 2000);
        
        playSound('fusion');
      }

      // ==================== GAME LOGIC ====================

      function selectHero(heroName) {
        const hero = heroes.find(h => h.name === heroName);
        if (!hero) return;
        
        // Reset game state
        state.players = [];
        state.playerCount = 1;
        state.numHumans = 1;
        state.round = 1;
        state.currentPlayerIndex = 0;
        state.isShopPhase = true;
        state.gameOver = false;
        state.messageLog = [];
        state.selectedIndices = [];
        
        const player = createPlayer(true, hero);
        addPlayer(player);
        refreshShopForPlayer(player);
        startBackgroundMusic();
        
        addMessage(`${hero.name} selected! Your journey begins.`);
        renderGameScreen();
      }

      function buyUnit(index) {
        const player = getCurrentPlayer();
        if (!player || state.gameOver) return;
        
        const unitName = player.shop[index];
        const cost = getUnitCost(unitName);
        
        if (player.gold < cost) {
          addMessage('Not enough gold!');
          return;
        }
        
        if (player.board.length >= player.boardLimit) {
          addMessage('Board is full!');
          return;
        }
        
        // Add click animation to the button
        const buyBtn = event.target;
        buyBtn.classList.add('animate-bounce');
        setTimeout(() => buyBtn.classList.remove('animate-bounce'), 600);
        
        // Add purchase animation to the shop card
        const shopCard = buyBtn.closest('.shop-card');
        if (shopCard) {
          shopCard.classList.add('animate-purchase');
          setTimeout(() => shopCard.classList.remove('animate-purchase'), 1000);
        }
        
        player.gold -= cost;
        const unit = createUnit(unitName);
        if (unit) {
          player.board.push(unit);
          state.gameStats.unitsBought++;
          addMessage(`Bought ${unitName} for ${cost} gold.`);
          console.log(`Unit bought: ${unitName}, Board length now: ${player.board.length}`);
          playSound('buy');
          
          // Apply after-play abilities using the new ability system
          abilitySystem.applyAfterPlayAbilities(unit, player);
          
          // Add visual feedback for the new unit on board
          setTimeout(() => {
            const boardSlots = document.querySelectorAll('.board-slot');
            const lastSlot = boardSlots[player.board.length - 1];
            if (lastSlot) {
              lastSlot.classList.add('animate-scale-in');
              setTimeout(() => lastSlot.classList.remove('animate-scale-in'), 600);
            }
          }, 100);
        }
        
        // Update only the necessary parts instead of full re-render
        updateGameDisplay();
      }

      function handleBoardClick(index) {
        const player = getCurrentPlayer();
        if (!player || state.gameOver) return;
        
        if (state.selectedIndices.includes(index)) {
          // Deselect
          state.selectedIndices = state.selectedIndices.filter(i => i !== index);
        } else if (player.board[index]) {
          // Select
          state.selectedIndices.push(index);
          
          if (state.selectedIndices.length === 2) {
            attemptFusionFromSelection();
          }
        } else {
          // Try to move selected unit to empty slot
          if (state.selectedIndices.length === 1) {
            const selectedIndex = state.selectedIndices[0];
            if (player.board[selectedIndex]) {
              // Move unit
              const unit = player.board[selectedIndex];
              player.board[selectedIndex] = null;
              player.board[index] = unit;
              // Clean up null entries
              player.board = player.board.filter(u => u !== null);
              clearSelection();
              addMessage(`Moved ${unit.name} to position ${index + 1}`);
            }
          }
        }
        
        updateGameDisplay();
      }

      function attemptFusionFromSelection() {
        const player = getCurrentPlayer();
        const [index1, index2] = state.selectedIndices;
        
        const unit1 = player.board[index1];
        const unit2 = player.board[index2];
        
        if (!unit1 || !unit2) {
          clearSelection();
          return;
        }
        
        const fusionResult = attemptFusion(unit1, unit2);
        
        if (fusionResult) {
          const fusedUnit = createUnit(fusionResult);
          
                  if (fusedUnit) {
          // Remove the two units and add the fused one
          const newBoard = [];
          for (let i = 0; i < player.board.length; i++) {
            if (i !== index1 && i !== index2) {
              newBoard.push(player.board[i]);
            }
          }
          newBoard.push(fusedUnit);
          player.board = newBoard;
          
          state.gameStats.fusionsCreated++;
          addMessage(`Fused ${unit1.name} + ${unit2.name} = ${fusionResult}!`);
          showFusionAnimation(fusedUnit.emoji);
          checkAchievements();
        }
        } else {
          addMessage(`Cannot fuse ${unit1.name} and ${unit2.name} - no valid fusion combination.`);
        }
        
        clearSelection();
        updateGameDisplay();
      }

      function doBattle() {
        const player = getCurrentPlayer();
        if (!player || player.board.length === 0) {
          addMessage('You have no units to battle with.');
          return;
        }
        
        playSound('battle');
        
        const opponent = generateOpponent(state.round);
        
        // Create copies of units for visual battle
        const playerUnits = player.board.map(unit => ({
          ...unit,
          maxHealth: unit.health,
          emoji: NEW_UNIT_DEFINITIONS[unit.name]?.emoji || '❓'
        }));
        
        const opponentUnits = opponent.map(unit => ({
          ...unit,
          maxHealth: unit.health,
          emoji: NEW_UNIT_DEFINITIONS[unit.name]?.emoji || '❓'
        }));
        
        // Simulate battle to get final results
        const result = simulateBattle(player.board, opponent, player.heroAbility, null);
        
        const pDamage = result.playerSurvivorDamage || 0;
        const oDamage = result.opponentSurvivorDamage || 0;
        const pHeal = result.playerHeal || 0;
        
        // Render visual battle screen with initial units
        renderBattleScreen(playerUnits, opponentUnits, result.log, pDamage, oDamage, pHeal, 0);
      }

      function finishBattle(pDamage, oDamage, pHeal = 0, oHeal = 0) {
        const player = getCurrentPlayer();
        
        // Show synergy sidebar again
        const sidebar = document.querySelector('.synergy-sidebar');
        if (sidebar) {
          sidebar.style.display = 'block';
        }
        
        // Update statistics
        state.gameStats.totalDamageDealt += oDamage;
        state.gameStats.totalDamageReceived += pDamage;
        checkAchievements();
        
        // Apply damage and healing to player
        player.heroHealth -= pDamage;
        if (player.heroHealth < 0) player.heroHealth = 0;
        
        if (pHeal > 0) {
          player.heroHealth = Math.min(player.heroMaxHealth, player.heroHealth + pHeal);
        }
        
        // Apply damage to opponent
        state.opponentHealth -= oDamage;
        if (state.opponentHealth < 0) state.opponentHealth = 0;
        
        // Check win/lose conditions
        if (player.heroHealth <= 0) {
          state.gameStats.battlesLost++;
          renderGameOver(false);
          return;
        }
        
        if (state.opponentHealth <= 0) {
          state.gameStats.battlesWon++;
          renderGameOver(true);
          return;
        }
        
        // Continue to next round
        finishRound();
      }

      function finishRound() {
        const player = getCurrentPlayer();
        
        state.round++;
        state.gameStats.roundsPlayed++;
        
        // Check for max rounds reached
        if (state.round > GAME_CONFIG.MAX_ROUNDS) {
          state.gameStats.battlesWon++;
          renderGameOver(true);
          return;
        }
        
        // Apply hero round start ability
        if (player.heroAbility && player.heroAbility.roundStart) {
          player.heroAbility.roundStart(player);
        }
        
        // Apply end-of-turn abilities using the new ability system
        abilitySystem.applyEndOfTurnAbilities(player);
        
        // Scale gold with rounds: base 3 + 1 per round
        const goldGain = GAME_CONFIG.GOLD_PER_ROUND + (state.round - 1);
        player.gold += goldGain;
        refreshShopForPlayer(player);
        
        addMessage(`Round ${state.round} begins! You gain ${goldGain} gold (base ${GAME_CONFIG.GOLD_PER_ROUND} + ${state.round - 1} bonus).`);
        
        state.isShopPhase = true;
        renderGameScreen();
      }

      // ==================== GLOBAL EXPORTS ====================

      // Make functions globally available for HTML onclick handlers
      window.selectHero = selectHero;
      window.buyUnit = buyUnit;
      window.handleBoardClick = handleBoardClick;
      window.attemptFusionFromSelection = attemptFusionFromSelection;
      window.doBattle = doBattle;
      window.finishBattle = finishBattle;
      window.showStats = showStats;
      window.saveGame = saveGame;
      window.loadGame = loadGame;
      window.skipBattle = skipBattle;
      window.startVisualBattle = startVisualBattle;

      // ==================== INITIALIZATION ====================

      function initializeGame() {
        console.log('🎮 Elemental Battlegrounds - Offline Version Starting...');
        initAudioVolume();
        
        // Add a small delay to show loading screen
        setTimeout(() => {
          renderStartScreen();
          console.log('✅ Game initialized successfully!');
        }, 1000);
      }

      // Initialize when DOM is ready
      if (document.readyState === 'loading') {
        window.addEventListener('DOMContentLoaded', initializeGame);
      } else {
        initializeGame();
      }
    })();
  </script>
</body>
</html>